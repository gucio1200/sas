mod sas;
use crate::sas::generate_container_sas;
use kube::{Api, Client};
use k8s_openapi::api::core::v1::ConfigMap;
use kube::api::{Patch, PatchParams};
use tokio;
use futures::stream::StreamExt;
use std::{fs, collections::BTreeMap};
use time::{OffsetDateTime, Duration, format_description::well_known::Rfc3339};
use anyhow::Result;
use tracing::{info, warn, error, Level};
use tracing_subscriber::EnvFilter;

#[derive(Clone, Debug)]
struct Config {
    root_cm_name: String,
    validity_hours: i64,
    recheck_hours: i64,
    poll_interval: u64,
}

impl Config {
    fn from_env() -> Result<Self> {
        Ok(Self {
            root_cm_name: std::env::var("SA_MAP")
                .map_err(|_| anyhow::anyhow!("Missing env var SA_MAP"))?,
            validity_hours: std::env::var("SAS_TTL")
                .ok()
                .and_then(|v| v.parse().ok())
                .unwrap_or(2),
            recheck_hours: std::env::var("RECHECK")
                .ok()
                .and_then(|v| v.parse().ok())
                .unwrap_or(1),
            poll_interval: std::env::var("POLL_INTERVAL")
                .ok()
                .and_then(|v| v.parse().ok())
                .unwrap_or(10),
        })
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env().add_directive(Level::INFO.into()))
        .with_target(false)
        .init();

    let cfg = Config::from_env()?;
    let client = Client::try_default().await?;
    let namespace = current_namespace()?;
    let api: Api<ConfigMap> = Api::namespaced(client.clone(), &namespace);

    info!("üöÄ SAS Daemon started. Polling every {}s", cfg.poll_interval);

    let shutdown_signal = tokio::signal::ctrl_c();
    tokio::pin!(shutdown_signal);

    loop {
        tokio::select! {
            _ = &mut shutdown_signal => {
                info!("üõë Shutdown signal received. Exiting daemon...");
                break;
            }

            _ = poll_accounts(&api, &cfg) => {}

            _ = tokio::time::sleep(tokio::time::Duration::from_secs(cfg.poll_interval)) => {}
        }
    }

    info!("‚úÖ Daemon stopped.");
    Ok(())
}

fn current_namespace() -> Result<String> {
    Ok(fs::read_to_string("/var/run/secrets/kubernetes.io/serviceaccount/namespace")?
        .trim()
        .to_string())
}

async fn poll_accounts(api: &Api<ConfigMap>, cfg: &Config) -> Result<()> {
    match api.get(&cfg.root_cm_name).await {
        Ok(root_cm) => {
            let accounts: Vec<(String, String)> = root_cm
                .data
                .unwrap_or_default()
                .into_iter()
                .collect();

            futures::stream::iter(accounts)
                .for_each_concurrent(10, |(account, container)| {
                    let api = api.clone();
                    let cfg = cfg.clone();
                    async move {
                        if let Err(e) = process_account_container(&api, &account, &container, &cfg).await {
                            error!(?e, %account, %container, "Error processing container");
                        }
                    }
                })
                .await;
        }
        Err(e) => {
            warn!(?e, "Failed to fetch root ConfigMap '{}'", cfg.root_cm_name);
        }
    }

    Ok(())
}

async fn process_account_container(
    api: &Api<ConfigMap>,
    account: &str,
    container: &str,
    cfg: &Config,
) -> Result<()> {
    let cm_name = format!("{}-{}", account, container);

    match needs_regeneration(api, &cm_name, cfg.recheck_hours).await? {
        RegenerationCheck::Valid(remaining) => {
            info!(%cm_name, left = %format_friendly_duration(remaining), "‚úÖ Token still valid");
            return Ok(());
        }
        RegenerationCheck::NeedsRegen => {
            info!(%cm_name, "üîÑ Generating new SAS token...");
        }
    }

    // Retry with exponential backoff for transient errors
    let mut attempts = 0;
    let (sas_token, expiry) = loop {
        match generate_container_sas(account, container, cfg.validity_hours).await {
            Ok(r) => break r,
            Err(e) if attempts < 3 => {
                attempts += 1;
                warn!(?e, attempt = attempts, "Temporary failure; retrying...");
                tokio::time::sleep(tokio::time::Duration::from_secs(2_u64.pow(attempts))).await;
            }
            Err(e) => {
                error!(?e, "‚ùå Failed to generate SAS after retries");
                return Err(e);
            }
        }
    };

    update_config_map(api, &cm_name, account, container, &sas_token, &expiry).await?;
    info!(%cm_name, expires_at = %expiry.format(&Rfc3339)?, "üÜï SAS token updated");

    Ok(())
}

enum RegenerationCheck {
    Valid(Duration),
    NeedsRegen,
}

async fn needs_regeneration(api: &Api<ConfigMap>, cm_name: &str, recheck_hours: i64) -> Result<RegenerationCheck> {
    match api.get(cm_name).await {
        Ok(cm) => {
            if let Some(expiry_str) = cm.data.and_then(|d| d.get("expiry").cloned()) {
                if let Ok(expiry) = OffsetDateTime::parse(&expiry_str, &Rfc3339) {
                    let now = OffsetDateTime::now_utc();
                    let remaining = expiry - now;
                    if remaining.is_positive() {
                        let threshold = Duration::hours(recheck_hours);
                        if remaining > threshold {
                            return Ok(RegenerationCheck::Valid(remaining));
                        }
                    }
                    warn!(%cm_name, "‚ö†Ô∏è Token nearing expiry or expired");
                    return Ok(RegenerationCheck::NeedsRegen);
                }
            }
            warn!(%cm_name, "‚ö†Ô∏è Missing or invalid expiry field ‚Äî regenerating");
            Ok(RegenerationCheck::NeedsRegen)
        }
        Err(_) => {
            info!(%cm_name, "‚ÑπÔ∏è ConfigMap not found ‚Äî will create new SAS token");
            Ok(RegenerationCheck::NeedsRegen)
        }
    }
}

async fn update_config_map(
    api: &Api<ConfigMap>,
    cm_name: &str,
    account: &str,
    container: &str,
    sas_token: &str,
    expiry: &OffsetDateTime,
) -> Result<()> {
    let cm_data = BTreeMap::from([
        ("sas_token".into(), sas_token.to_string()),
        ("expiry".into(), expiry.format(&Rfc3339)?),
        ("account".into(), account.into()),
        ("container".into(), container.into()),
    ]);

    let cm = ConfigMap {
        metadata: kube::api::ObjectMeta { name: Some(cm_name.to_string()), ..Default::default() },
        data: Some(cm_data),
        ..Default::default()
    };

    api.patch(cm_name, &PatchParams::apply("sas-generator"), &Patch::Apply(&cm)).await?;
    Ok(())
}

fn format_friendly_duration(d: Duration) -> String {
    let total_seconds = d.whole_seconds();
    if total_seconds <= 0 {
        return "expired".to_string();
    }
    let hours = total_seconds / 3600;
    let minutes = (total_seconds % 3600) / 60;

    match (hours, minutes) {
        (0, m) => format!("{m}m left"),
        (h, 0) => format!("{h}h left"),
        (h, m) => format!("{h}h {m}m left"),
    }
}
