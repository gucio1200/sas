mod sas;
use crate::sas::generate_container_sas;
use kube::{Api, Client};
use k8s_openapi::api::core::v1::ConfigMap;
use kube::api::{Patch, PatchParams};
use futures::stream::StreamExt;
use std::{env, fs, collections::BTreeMap};
use time::{OffsetDateTime, Duration};
use time::format_description::well_known::Rfc3339;
use anyhow::Result;

#[tokio::main]
async fn main() -> Result<()> {
    // Load environment variables with defaults
    let root_cm_name = env::var("SA_MAP")?;
    let validity_hours: i64 = env::var("SAS_TTL").unwrap_or_else(|_| "2".to_string()).parse().unwrap_or(2);
    let recheck_hours: i64 = env::var("RECHECK").unwrap_or_else(|_| "1".to_string()).parse().unwrap_or(1);
    let poll_interval_secs: u64 = env::var("POLL_INTERVAL")
        .unwrap_or_else(|_| "10".to_string())
        .parse()
        .unwrap_or(10);

    let client = Client::try_default().await?;
    let namespace = current_namespace()?;
    let api: Api<ConfigMap> = Api::namespaced(client.clone(), &namespace);

    println!("SAS Daemon started. Polling every {} seconds...", poll_interval_secs);

    // Shutdown signal
    let shutdown_signal = tokio::signal::ctrl_c();
    tokio::pin!(shutdown_signal);

    loop {
        tokio::select! {
            _ = &mut shutdown_signal => {
                println!("Shutdown signal received. Exiting daemon...");
                break;
            }

            _ = poll_accounts(&api, &root_cm_name, validity_hours, recheck_hours) => {}

            _ = tokio::time::sleep(tokio::time::Duration::from_secs(poll_interval_secs)) => {}
        }
    }

    println!("Daemon stopped.");
    Ok(())
}

/// Read current namespace from the Kubernetes service account
fn current_namespace() -> Result<String> {
    Ok(fs::read_to_string("/var/run/secrets/kubernetes.io/serviceaccount/namespace")?
        .trim()
        .to_string())
}

/// Fetch root ConfigMap and process all account-container pairs concurrently
async fn poll_accounts(
    api: &Api<ConfigMap>,
    root_cm_name: &str,
    validity_hours: i64,
    recheck_hours: i64,
) -> Result<()> {
    let root_cm = api.get(root_cm_name).await?;
    let accounts: Vec<(String, String)> = root_cm
        .data
        .unwrap_or_default()
        .into_iter()
        .collect();

    futures::stream::iter(accounts)
        .for_each_concurrent(10, |(account, container)| {
            let api = api.clone();
            async move {
                if let Err(e) = process_account_container(&api, &account, &container, validity_hours, recheck_hours).await {
                    eprintln!("Error for {}-{}: {:?}", account, container, e);
                }
            }
        })
        .await;

    Ok(())
}

/// Check if a SAS token needs regeneration and create/update ConfigMap if needed
async fn process_account_container(
    api: &Api<ConfigMap>,
    account: &str,
    container: &str,
    validity_hours: i64,
    recheck_hours: i64,
) -> Result<()> {
    let cm_name = format!("{}-{}", account, container);

    if !needs_regeneration(api, &cm_name, recheck_hours).await? {
        println!("ConfigMap '{}' SAS token still valid", cm_name);
        return Ok(());
    }

    let (sas_token, expiry) = generate_container_sas(account, container, validity_hours).await?;
    update_config_map(api, &cm_name, account, container, &sas_token, &expiry).await?;

    println!("ConfigMap '{}' created/updated", cm_name);
    Ok(())
}

/// Check if a ConfigMap needs a new SAS token
async fn needs_regeneration(api: &Api<ConfigMap>, cm_name: &str, recheck_hours: i64) -> Result<bool> {
    match api.get(cm_name).await {
        Ok(cm) => {
            if let Some(expiry_str) = cm.data.and_then(|d| d.get("expiry").cloned()) {
                if let Ok(expiry) = OffsetDateTime::parse(&expiry_str, &Rfc3339) {
                    return Ok(OffsetDateTime::now_utc() + Duration::hours(recheck_hours) > expiry);
                }
            }
            Ok(true)
        }
        Err(_) => Ok(true), // Missing ConfigMap â†’ regenerate
    }
}

/// Patch or create the ConfigMap for the SAS token
async fn update_config_map(
    api: &Api<ConfigMap>,
    cm_name: &str,
    account: &str,
    container: &str,
    sas_token: &str,
    expiry: &OffsetDateTime,
) -> Result<()> {
    let cm_data = BTreeMap::from([
        ("sas_token".into(), sas_token.to_string()),
        ("expiry".into(), expiry.format(&Rfc3339)?),
        ("account".into(), account.into()),
        ("container".into(), container.into()),
    ]);

    let cm = ConfigMap {
        metadata: kube::api::ObjectMeta { name: Some(cm_name.to_string()), ..Default::default() },
        data: Some(cm_data),
        ..Default::default()
    };

    api.patch(cm_name, &PatchParams::apply("sas-generator"), &Patch::Apply(&cm)).await?;
    Ok(())
}
